# DAG + Cython

Учебный проект с реализацией вычислительного графа (DAG — directed acyclic graph) для численных операций.  
Основной упор сделан на производительность за счёт использования **Cython** и **NumPy**.

## Идея

- вычисления представляются в виде направленного ациклического графа
- узлы графа — операции над массивами
- рёбра — зависимости по данным
- вычисление запускается вызовом `forward()`

Проект похож по идее на autograd / PyTorch (forward-граф), но без автоматического дифференцирования.

## Возможности

- базовые арифметические операции
- цепочки операций через DAG
- работа с NumPy-массивами
- ускорение критичных частей через Cython

## Пример

```python
import numpy as np
from graph_cython import Input, SumDouble, Product

a = Input(np.arange(5.0))
b = Input(np.arange(5.0) * 2.0)

c = SumDouble(a, b)
d = Product(c, a)

result = d.forward()
print(result)
```


## Как это работает

- `Input` — источник данных (NumPy-массив)
- каждый узел хранит ссылки на входные узлы
- вычисление происходит лениво
- реальный расчёт начинается при вызове `forward()`
- порядок вычислений соответствует DAG

Python отвечает за структуру графа,  
Cython — за быстрые численные вычисления.

## Оптимизация через Cython

В горячих местах используются:

- директивы  
  `boundscheck=False`, `wraparound=False`, `cdivision=True`
- статическая типизация (`cdef`)
- `Py_ssize_t` в циклах
- минимальное взаимодействие с Python внутри вычислений

Цель — убрать лишний overhead и приблизиться к скорости C.

## Сборка проекта

Установка зависимостей:

```bash
pip install -r requirements.txt
